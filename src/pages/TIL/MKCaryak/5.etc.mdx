# etc

사용법 위주로 불성실한 코드 설명

## useEffect

```javascript
useEffect(() => {
  let a = a;
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

[]안의 값이 바뀔때마다, 실행할 함수 적어주기  
주석 처리된 내용의 경우, 관련한 effect와 관련되있지 않을경우 권장 하지 않고 warning이 뜨게되는데, 이를 무시하는 처리

## useMutation

```javascript
const getStationSettlementUsage = useMutation(_aGetStationSettlementUsageById);
```

mutation 안에 api 주소 셋팅후 준비후

```javascript
await getStationSettlementUsage.mutateAsync(data, {
  onSuccess: () => {
    whenSuccessed();
  },
  onError: () => {
    whenFailed();
  },
});
```

형태로 이용하게 된다. api 호출 성공시 성공을, 실패시 실패에 해당하는 함수를 입맛에 맞게

## useQuery

```javascript
const createdStationSettlementSummary = useQuery(
  ["stationSettlementSummary"],
  () => _aGetStationSettlementUsage(findParam.current),
  {
    enabled: true,
    onSuccess: (data) => {},
  }
);
```

useQuery의 경우 랜더링 후 바로 사용하는 GET과 관련한 api를 사용하였다.  
mutate는 patch,delete 또는 get을 동작 이후에 할때 사용했다.  
쿼리의 경우 새롭게 갱신된 데이터가 있을때 refetch를 사용함으로써, 새롭게 데이터를 받아올수있다. (enable 옵션 true인경우)

# NGINX

웹서버 = get 전용만 하는 서버
WAS = 자바, PHP 등

http = :80  
https = :443  
SSH = :22

루트로 들어온 사람은 3000으로 보내기
루트/api로 부르면 3001로 보내기

1. path에 따른 라우팅
2. 호스트 라우팅
3. SSL 인증서

RT 인증 함호기 (최고 루트의 암호키)
를 이용해서 만드는 암호키를 타고 타고 타고.. 를 만드는 암호키

인증서에 호스트 네임, 만료 날짜등등

http는 get - response 끝  
https는 인증서 받고 인증서 확인하고 연결 알고리즘 선택 후 get- response

# Devops...

기왕이면 깃 확인해가면서

# Constructor (생성자)

```javascript
export class AttendanceController {
constructor(private readonly service: AttendanceService) {}
  @Patch('punch/all')
  @ApiOperation({ summary: '해당 날짜 Patch' })
  @ApiBody({ type: AttendanceItem })
  @ApiCreatedResponse({ type: Attendance })
  async patchPunchAll(@Body() data: AttendanceItem) {
    return await this.service.patchDailyAttendace(data);
  }
}
```

백엔드 controller 작성시 사용하게된 constructor.  
직접 작업하는 파트 AttendanceService를 불러왔고,
async 함수 return 값에 위에서 호출한 service 에 this가 붙어있다는 점이 보인다.

먼저 알아봐야할 것으로 constructor (생성자)가 무엇인가 부터 인스턴스를 초기화 하는 메서드 인데...  
정해진 키밸류를 가진 객체를 편리하게 생성하고 비슷한 객체를 일일이 만들지 않고 하나의 생성자로 사용해서 편하게 인스턴스 생성을 가능케한다..
라는데..

```javascript
export const Cat = (name: string, age: number) => {
  this.name = name;
  this.age = age;
  this.summary = () => {
    console.log(`cat's name : ${name},age : ${age}`);
  };
};
```

함수로 비슷하게 만들어 본것

```javascript
export const cat = (name: string, age: number) => {
  name() {
    return name;
  }
  age() {
    return age;
  }
};
```

기존 함수랑 차이점은 this.을 통해 키값에 접근할수있게 해준다.  
ex) Cat.name, Cat.summary()

```javascript
let cat1 = new Cat("A", 1);
let cat2 = new Cat("B", 2);
```

이렇게 cat1 과 cat2라는 인스턴스를 빠르게 만들어 냈고, 각각 이름과 나이를 들고있다.

# 접근 제한자

접근을 제한하기 위해 사용하는것. 클래스 , 인터페이스 등 멤버의 접근을 얘기한다.  
Java에서의 접근자를 확인해보면

- public : 외부 클래스가 자유롭게 사용하는것 (js : export class)
- protected : 같은 패키지내애서는 사용 가능..
- private : 외부에서 사용하지 않는다.

즉 private를 사용 하게 되면

```javascript
 const hi = (msg) => {
  public const add = () => {
    const msg2 = `${msg} + ${"!"}`
    return msg2;
  }
  const final = add(msg)
  return final;
}
```

위에서 만든 add는 hi 라는 함수 내에서만 사용할수 있으며, 밖에서 호출할수 없다.
hi.add() 불가능
